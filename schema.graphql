type User @entity {
    id: ID! # ethereum account
    filledOrdersMaker: [FilledOrder!] @derivedFrom(field: "maker") # TODO: there are maker taker duplicates , do we need to deal with this? probably not
    filledOrdersTaker: [FilledOrder!] @derivedFrom(field: "taker")
    filledOrdersFeeRecipient: [FilledOrder!] @derivedFrom(field: "feeRecipient")
    cancelled: [CancelledOrder!] @derivedFrom(field: "maker")
    proxiesApproved: [Bytes] # must be updated in same mapping as ProxyApprovedAddresses
    validatorsApproved: [Bytes] # event SignatureValidationApproval - allows me to give any other address the ability to sign for me
}

type FilledOrder @entity {
    maker: Bytes!
    feeRecipient: Bytes # it is likely to be the relayer, but the relayer could also change their address that recievies fees
    taker: Bytes!
    sender: Bytes! # is this the relayer, or m or t, or 3rd party? figure out when query
    makerAssetFilledAmount: BigInt
    takerAssetFilledAmount: BigInt
    makerFeePaid: BigInt # I think this goes to relayer, in general
    takerFeePaid: BigInt # I think this goes to relayer, in general
    id: ID! # orderHash (unqiue because of the salt)
    makerAssetData: Bytes # a special hash of ERC20 / ERC721 + the address. basically just the addr, and if it is ERC721 it also has the token id # TODO: change to human readable (coin & token id)
    takerAssetData: Bytes # a special hash of ERC20 / ERC721 + the address. basically just the addr, and if it is ERC721 it also has the token id
}

type CancelledOrder @entity {
    maker: Bytes # some reason this cancels on null
    feeRecipient: Bytes
    sender: Bytes!
    id: ID! # orderHash
    makerAssetData: Bytes!
    takerAssetData: Bytes!
}

# event AssetProxyRegister
# TODO: Decide if we should remove this, it only has two events, it's not that special
type ApprovedProxy @entity {
    id: ID! # id field
    assetProxyAddress: Bytes!
}


# THERE IS NO ID FOR THIS, it isnt needed. It will cancelOrders, and a cancel order event will be released as a result
# you could actually hash maker and sender together, and note their order epoch that is cancelled up to, if that is desirable . But I don't see the point now
#type CancelledUpToOrders {
#    maker: Bytes!
#    sender: Bytes!
#    orderEpoch: BigInt!
#}

# commented out, takes too long, and not that useful
#type ZRXTokenOwner @entity {
#    id: ID! # owner
#    amount: BigInt!
#    allowance: [AllowanceApproval!] @derivedFrom(field: "tokenOwner") # not linking up!
#}

#type AllowanceApproval @entity {
#    id: ID! # owner
#    approvedAddress: Bytes!
#    amount: BigInt!
#    tokenOwner: ZRXTokenOwner!
#
#}
