type User @entity {
    id: ID! # ethereum account
    filledOrders: [FilledOrders!] @derivedFrom(field: "user")
    feesRecieved: [BigInt]
    cancelled: [CancelledOrders!] @derivedFrom(field: "user")
    proxiesApproved: [Bytes] # must be updated in same mapping as ProxyApprovedAddresses
    validatorsApproved: [Bytes] # event SignatureValidationApproval - allows me to give any other address the ability to sign for me
#   openOrders: [Bytes] can't get this without hitting off chain data
}

# This is based on the relayer being likely to recieve all fees.
type Relayer @entity {
    id: ID! # ethereum account where relayer recieves fees
    FilledOrders: [FilledOrders!] @derivedFrom(field: "relayer")
#   feesRecieved: [BigInt] # must add together maker and Taker fees. I don't really need this, it is duplicate data. TODO: remove
#   openOrders: [Bytes] can't get this without hitting off chain data
}

# this should show fees and assets traded
# FIXME: This shouldnt be pluralized

type FilledOrders @entity {
    maker: Bytes!
    feeRecipient: Bytes # it is likely to be the relayer, but the relayer could also change their address that recievies fees
    taker: Bytes!
    sender: Bytes! # is this the relayer, or m or t, or 3rd party? figure out when query
    makerAssetFilledAmount: BigInt
    takerAssetFilledAmount: BigInt
    makerFeePaid: BigInt # I think this goes to relayer, in general
    takerFeePaid: BigInt # I think this goes to relayer, in general
    id: ID! # orderHash (unqiue because of the salt)
    makerAssetData: Bytes # a special hash of ERC20 / ERC721 + the address. basically just the addr, and if it is ERC721 it also has the token id
    takerAssetData: Bytes # a special hash of ERC20 / ERC721 + the address. basically just the addr, and if it is ERC721 it also has the token id
    user: User!
    relayer: Relayer!
}

# FIXME: This shouldnt be pluralized
type CancelledOrders @entity {
    maker: Bytes!
    feeRecipient: Bytes
    sender: Bytes!
    id: ID! # orderHash
    makerAsserData: Bytes!
    takerAssetData: Bytes!
    user: User!
}

# event AuthorizedAddressAdded - whenever someone gives proxy approval to tranfer for them
# event AuthorizedAddressRemoved - removing proxy to transfer for you
# FIXME: This shouldnt be pluralized
type ProxyApprovedAddresses @entity {
    id: ID! # proxy address i.e. ERC721 or ERC20 proxy addresses
    approvedAddresses: [Bytes]!
}

# event AssetProxyRegister - I believe this should be only be emitted twice as of right now, just ERC20 and ERC721 asset
# FIXME: This shouldnt be pluralized
type ApprovedProxyAddresses @entity {
    id: ID! # id field
    assetProxyAddress: Bytes!
}


# THERE IS NO ID FOR THIS, it isnt needed. It will cancelOrders, and a cancel order event will be released as a result
# you could actually hash maker and sender together, and note their order epoch that is cancelled up to, if that is desirable . But I don't see the point now
#type CancelledUpToOrders {
#    maker: Bytes!
#    sender: Bytes!
#    orderEpoch: BigInt!
#}



# commented out, takes too long, and not that useful
#type ZRXTokenOwner @entity {
#    id: ID! # owner
#    amount: BigInt!
#    allowance: [AllowanceApproval!] @derivedFrom(field: "tokenOwner")
#}
#
#type AllowanceApproval @entity {
#    id: ID! # owner
#    approvedAddress: Bytes!
#    amount: BigInt!
#    tokenOwner: ZRXTokenOwner!
#
#}
